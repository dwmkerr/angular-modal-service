{"version":3,"sources":["angular-modal-service.js"],"names":["module","angular","factory","$document","$compile","$controller","$http","$rootScope","$q","$templateCache","ModalService","self","this","getTemplate","template","templateUrl","deferred","defer","resolve","cachedTemplate","get","undefined","method","url","cache","then","result","put","data","error","reject","promise","showModal","options","controllerName","controller","controllerAs","modalScope","$new","closeDeferred","inputs","$scope","close","delay","window","setTimeout","$destroy","modalElement","remove","modal","inputName","modalElementTemplate","element","linkFn","$element","modalController","appendElement","append","body","scope","find"],"mappings":"CAMC,WAEC,YAEA,IAAIA,GAASC,QAAQD,OAAO,yBAE5BA,GAAOE,QAAQ,gBAAiB,YAAa,WAAY,cAAe,QAAS,aAAc,KAAM,iBACjG,SAASC,EAAWC,EAAUC,EAAaC,EAAOC,EAAYC,EAAIC,GAKhE,QAASC,KAEP,GAAIC,GAAOC,KAKPC,EAAc,SAASC,EAAUC,GACnC,GAAIC,GAAWR,EAAGS,OAClB,IAAGH,EACDE,EAASE,QAAQJ,OACZ,IAAGC,EAAa,CAErB,GAAII,GAAiBV,EAAeW,IAAIL,EAClBM,UAAnBF,EACDH,EAASE,QAAQC,GAIjBb,GAAOgB,OAAQ,MAAOC,IAAKR,EAAaS,OAAO,IAC1CC,KAAK,SAASC,GAEbjB,EAAekB,IAAIZ,EAAaW,EAAOE,MACvCZ,EAASE,QAAQQ,EAAOE,OACvB,SAASC,GACVb,EAASc,OAAOD,SAIxBb,GAASc,OAAO,iDAElB,OAAOd,GAASe,QAGlBpB,GAAKqB,UAAY,SAASC,GAGxB,GAAIjB,GAAWR,EAAGS,QAGdiB,EAAiBD,EAAQE,UAC7B,OAAID,IAODD,EAAQG,eACTF,EAAiBA,EAAiB,OAASD,EAAQG,cAIrDvB,EAAYoB,EAAQnB,SAAUmB,EAAQlB,aACjCU,KAAK,SAASX,GAGb,GAAIuB,GAAa9B,EAAW+B,OAQxBC,EAAgB/B,EAAGS,QACnBuB,GACFC,OAAQJ,EACRK,MAAO,SAAShB,EAAQiB,IACTtB,SAAVsB,GAAiC,OAAVA,KAAgBA,EAAQ,GAClDC,OAAOC,WAAW,WAEhBN,EAAcrB,QAAQQ,GAGtBW,EAAWS,WACXC,EAAaC,SAKbR,EAAOE,MAAQ,KACf1B,EAAW,KACXuB,EAAgB,KAChBU,EAAQ,KACRT,EAAS,KACTO,EAAe,KACfV,EAAa,MACZM,IAKP,IAAGV,EAAQO,OACT,IAAI,GAAIU,KAAajB,GAAQO,OAC3BA,EAAOU,GAAajB,EAAQO,OAAOU,EAKvC,IAAIC,GAAuBlD,QAAQmD,QAAQtC,GAIvCuC,EAASjD,EAAS+C,GAClBJ,EAAeM,EAAOhB,EAC1BG,GAAOc,SAAWP,CAGlB,IAAIQ,GAAkBlD,EAAY6B,EAAgBM,EAG9CP,GAAQuB,cAEVvB,EAAQuB,cAAcC,OAAOV,GAG7BW,EAAKD,OAAOV,EAId,IAAIE,IACFd,WAAYoB,EACZI,MAAOtB,EACPe,QAASL,EACTL,MAAOH,EAAcR,QAIvBf,GAASE,QAAQ+B,KAGlBxB,KAAK,KAAM,SAASI,GACnBb,EAASc,OAAOD,KAGfb,EAASe,UA9Fdf,EAASc,OAAO,qCACTd,EAASe,UA7CtB,GAAI2B,GAAOvD,EAAUyD,KAAK,OA+I1B,OAAO,IAAIlD","file":"angular-modal-service.min.js","sourcesContent":["//  angularModalService.js\n//\n//  Service for showing modal dialogs.\n\n/***** JSLint Config *****/\n/*global angular  */\n(function() {\n\n  'use strict';\n\n  var module = angular.module('angularModalService', []);\n\n  module.factory('ModalService', ['$document', '$compile', '$controller', '$http', '$rootScope', '$q', '$templateCache',\n      function($document, $compile, $controller, $http, $rootScope, $q, $templateCache) {\n\n        //  Get the body of the document, we'll add the modal to this.\n        var body = $document.find('body');\n\n        function ModalService() {\n\n          var self = this;\n\n          //  Returns a promise which gets the template, either\n          //  from the template parameter or via a request to the\n          //  template url parameter.\n          var getTemplate = function(template, templateUrl) {\n            var deferred = $q.defer();\n            if(template) {\n              deferred.resolve(template);\n            } else if(templateUrl) {\n              // check to see if the template has already been loaded\n              var cachedTemplate = $templateCache.get(templateUrl);\n              if(cachedTemplate !== undefined) {\n                deferred.resolve(cachedTemplate);\n              }\n              // if not, let's grab the template for the first time\n              else {\n                $http({method: 'GET', url: templateUrl, cache: true})\n                    .then(function(result) {\n                      // save template into the cache and return the template\n                      $templateCache.put(templateUrl, result.data);\n                      deferred.resolve(result.data);\n                    }, function(error) {\n                      deferred.reject(error);\n                    });\n              }\n            } else {\n              deferred.reject(\"No template or templateUrl has been specified.\");\n            }\n            return deferred.promise;\n          };\n\n          self.showModal = function(options) {\n\n            //  Create a deferred we'll resolve when the modal is ready.\n            var deferred = $q.defer();\n\n            //  Validate the input parameters.\n            var controllerName = options.controller;\n            if(!controllerName) {\n              deferred.reject(\"No controller has been specified.\");\n              return deferred.promise;\n            }\n\n            //  If a 'controllerAs' option has been provided, we change the controller\n            //  name to use 'as' syntax. $controller will automatically handle this.\n            if(options.controllerAs) {\n              controllerName = controllerName + \" as \" + options.controllerAs;\n            }\n\n            //  Get the actual html of the template.\n            getTemplate(options.template, options.templateUrl)\n                .then(function(template) {\n\n                  //  Create a new scope for the modal.\n                  var modalScope = $rootScope.$new();\n\n                  //  Create the inputs object to the controller - this will include\n                  //  the scope, as well as all inputs provided.\n                  //  We will also create a deferred that is resolved with a provided\n                  //  close function. The controller can then call 'close(result)'.\n                  //  The controller can also provide a delay for closing - this is\n                  //  helpful if there are closing animations which must finish first.\n                  var closeDeferred = $q.defer();\n                  var inputs = {\n                    $scope: modalScope,\n                    close: function(result, delay) {\n                      if(delay === undefined || delay === null) delay = 0;\n                      window.setTimeout(function() {\n                        //  Resolve the 'close' promise.\n                        closeDeferred.resolve(result);\n\n                        //  We can now clean up the scope and remove the element from the DOM.\n                        modalScope.$destroy();\n                        modalElement.remove();\n\n                        //  Unless we null out all of these objects we seem to suffer\n                        //  from memory leaks, if anyone can explain why then I'd\n                        //  be very interested to know.\n                        inputs.close = null;\n                        deferred = null;\n                        closeDeferred = null;\n                        modal = null;\n                        inputs = null;\n                        modalElement = null;\n                        modalScope = null;\n                      }, delay);\n                    }\n                  };\n\n                  //  If we have provided any inputs, pass them to the controller.\n                  if(options.inputs) {\n                    for(var inputName in options.inputs) {\n                      inputs[inputName] = options.inputs[inputName];\n                    }\n                  }\n\n                  //  Parse the modal HTML into a DOM element (in template form).\n                  var modalElementTemplate = angular.element(template);\n\n                  //  Compile then link the template element, building the actual element.\n                  //  Set the $element on the inputs so that it can be injected if required.\n                  var linkFn = $compile(modalElementTemplate);\n                  var modalElement = linkFn(modalScope);\n                  inputs.$element = modalElement;\n\n                  //  Create the controller, explicitly specifying the scope to use.\n                  var modalController = $controller(controllerName, inputs);\n\n                  //  Finally, append the modal to the dom.\n                  if (options.appendElement) {\n                    // append to custom append element\n                    options.appendElement.append(modalElement);\n                  } else {\n                    // append to body when no custom append element is specified\n                    body.append(modalElement);\n                  }\n\n                  //  We now have a modal object...\n                  var modal = {\n                    controller: modalController,\n                    scope: modalScope,\n                    element: modalElement,\n                    close: closeDeferred.promise\n                  };\n\n                  //  ...which is passed to the caller via the promise.\n                  deferred.resolve(modal);\n\n                })\n                .then(null, function(error) { // 'catch' doesn't work in IE8.\n                  deferred.reject(error);\n                });\n\n            return deferred.promise;\n          };\n\n        }\n\n        return new ModalService();\n      }]);\n\n}());"],"sourceRoot":"/source/"}